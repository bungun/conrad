import numpy as np
from numpy import copy as np_copy, sort as np_sort, \
	linspace, insert, std as stdev, zeros, nan
from scipy import stats
from collections import OrderedDict

"""
TODO: dvh.py docstring
"""

def canonical_string_to_tuple(string_constraint):
	""" TODO: docstring

	convert input string, in canonical form:
		"D{p} <= {d}" or "D{p} >= {d}"

	to canonical tuple 
		(d, p/100, '<') or (d, p/100, '>'), respectively
	"""
	left, right = string_constraint.split('=')
	fraction = float(left.strip('<').strip('>').strip('D')) / 100.
	dose = float(right.strip('Gy'))
	direction = '<' if '<' in string_constraint else '>'
	return (dose, fraction, direction)


def tuple_to_canonical_string(tuple_constraint):
	""" TODO: docstring

	convert input tuple, in canonical form:
		(d, f, '<') or (d, f, '>')

	to canonical string 
		"D{f * 100} <= {d}" or "D{f * 100} >= {d}", respectively
	"""
	d, f, ineq = tuple_constraint
	return "D{} {}= {}Gy".format(f * 100, ineq, d)

	return (dose, fraction, direction)

class DoseConstraint(object):
	"""
		Dose constraint is specified as a tuple:
		(dose, fraction, direction)

		`dose' must be a float in [0, +infty)
		`fraction' must be float in [0, 1]
		`direction' is a character in {'<', '>'}

		For instance,

		(30, 0.2, '<')

		is interpreted as the (upper) DVH constraint:

			D20 <= 30 Gy, i.e.,

		"no more than 20 percent of the structure voxels 
		may receive over 30Gy of dose",

		Conversely,
		(55, 0.8, '>')

		is interpreted as the (lower) DVH constaint:

			D80 >= 55 Gy, i.e.,
		
		"at least 80 percent of the structure voxels 
		must receive at least 55Gy of dose"

	"""

	def __init__(self, dose, fraction, direction):
		""" TODO: docstring """
		self.change(dose, fraction, direction)

	def change(self, dose, fraction, direction):
		""" TODO: docstring """
		if fraction < 0. or fraction > 1.:
			raise ValueError("fraction %f must be in [0,1]" % (fraction))
		self.dose_requested = dose
		self.fraction = fraction
		self.direction = direction
		self.dose_actual = None


	def set_actual_dose(self, slack):
		""" TODO: docstring """
		if slack is None:
			self.dose_actual = self.dose_requested
			return

		if self.direction == '<':
			self.dose_actual = self.dose_requested + slack
		else:
			self.dose_actual = self.dose_requested - slack

	@property
	def upper(self):
		""" TODO: docstring """
		return self.direction == '<'

	@property
	def plotting_data(self):
		""" TODO: docstring """
		return {'percentile' : 2 * [100 * self.fraction], 
			'dose' :[self.dose_requested, self.dose_actual], 
			'symbol' : self.direction}

	def get_maxmargin_fulfillers(self, y, had_slack = False):
		""" 
		given dose vector y, get the indices of the voxels that
		fulfill this dose constraint (self) with maximum margin

		given len(y), if m voxels are required to respect the
		dose constraint exactly, y is assumed to contain 
		at least m entries that respect the constraint
		(for instance, y is generated by a convex program
		that includes a convex restriction of the dose constraint)


		procedure:
		- get margins: (y - self.dose_requested)
		- sort margin indices by margin values 
		- if upper bound, return indices of p most negative entries 
			(first p of sorted indices; numpy.sort sorts small to large)
		- if lower bound, return indices p most positive entries 
			(last p of sorted indices; numpy.sort sorts small to large)
		
		p = percent non-violating * structure size
			= percent non-violating * len(y)

		"""

		non_viol = self.fraction if not self.upper else (1 - self.fraction)
		
		# int() conversion truncates
		n_returned = int(non_viol * len(y))

		start = 0 if self.upper else -n_returned
		end = n_returned if self.upper else -1
		if had_slack and self.dose_actual is not None:
			dose = self.dose_actual
		else:
			dose = self.dose_requested
		return (y - dose).argsort()[start:end]

	def __str__(self):
		return 'D{} {}= {}Gy\n'.format(
			100 * self.fraction,
			self.direction, 
			self.dose_requested)
			
class DoseSummary(object):
	"""
	TODO: DoseSummary docstring
	"""
	
	def __init__(self, percentiles = [0.01, 0.05, 0.25, 0.5, 0.75, 0.95, 0.99]):
		""" TODO: docstring """
		self.percentiles = percentiles
		self.scores = None
		self.mean = None
		self.stdev = None
		self.minimum = None
		self.maximum = None
	
	def make(self, y):
		self.mean = np.mean(y)
		self.stdev = np.std(y)
		self.minimum = np.amin(y)
		self.maximum = np.amax(y)
		self.scores = np.percentile(y, self.percentiles)
	

	@property
	def table_data(self):
		""" TODO: docstring """
		table = OrderedDict({'mean': self.mean})
		table['stdev'] = self.stdev
		table['min'] = self.minimum
		table['max'] = self.maximum
		# TODO: Append percentiles in summary table
		# for idx in xrange(1, len(self.scores)):
		#	plabel = 'p' + str(self.percentiles[idx])
		#	table[plabel] = self.scores[idx]
		return table
	
	@property
	def header(self):
		return self.table_data.keys()

class DoseDensity(object):
	"""
	TODO: DoseDistribution doctstring
	"""
	
	MAX_LENGTH = 1000
	
	def __init__(self):
		""" TODO: docstring """
		self.doses = None
		self.probabilities = None
	
	def make(self, y, maxlength = MAX_LENGTH, bw_method = None):
		""" TODO: docstring """
		if len(y) <= maxlength:
			doses = y[:]
		elif len(y) <= 2 * maxlength:
			doses = y[::2]
		else:
			doses = y[::len(y) / maxlength]
		
		density = stats.kde.gaussian_kde(doses, bw_method)
		self.doses = linspace(0, max(doses), len(doses))
		self.probabilities = density(self.doses)
	
	@property
	def plotting_data(self):
		""" TODO: docstring """
		return {'probability' : self.probabilities, 'dose' : self.doses}


class DVHCurve(object):
	""" 
	TODO: DVHCurve docstring
	"""

	MAX_LENGTH = 1000
	WEB_DIGITS = 4

	def __init__(self):
		""" TODO: docstring """
		self.doses = None
		self.dose_buffer = []
		self.percentiles = None
		self.length = None

	def make(self, y, maxlength = MAX_LENGTH):
		""" TODO: docstring """
		if len(y) <= maxlength:
			stride = 1
		elif len(y) <= 2 * maxlength:
			stride = 2
		else:
			stride = len(y) / maxlength

		length = len(y[::stride]) + 1

		if self.length != length:
			self.length = length
			self.doses = zeros(length)
			self.percentiles = zeros(length)
			self.doses[0] = 0.
			self.percentiles[0] = 100.
			self.percentiles[1:] = linspace(100, 0, length - 1)

		if len(self.dose_buffer) != len(y):
			self.dose_buffer = zeros(len(y))

		self.dose_buffer[:] = y[:]
		self.dose_buffer.sort()
		self.doses[1:] = self.dose_buffer[::stride]


	@staticmethod
	def __interpolate_percentile(p1, p2, p_des):
		""" TODO: docstring """
		# alpha * p1 + (1 - alpha) * p2 = p_des
		# (p1 - p2) * alpha = p_des - p2
		# alpha = (p_des - p2) / (p1 - p2)
		return (p_des - p2) / (p1 - p2)

	def dose_at_percentile(self, percentile):
		""" TODO: docstring """
		if self.doses is None: return nan

		print "REQUESTED:", percentile

		if percentile < 1.: percentile *= 100
		if percentile == 100: return self.mindose
		if percentile == 0: return self.maxdose

		for idx, p in enumerate(self.percentiles):
			print "percentile: ", p, "dose:", self.doses[idx]

		# bisection retrieval of dose @ percentile
 		u = len(self.percentiles) - 1
		l = 1
		i = l + (u - l) / 2

		# set tolerance based on bucket width
		tol = (self.percentiles[-2] - self.percentiles[-1]) / 2

		# get to within 0.5 of a percentile if possible
		abstol = 1 

		while (u - l > 5):
			# percentile sorted descending
			if self.percentiles[i] > percentile:
				l = i				
			else:
				u = i
			i = l + (u - l) / 2

		# break to iterative search
		idx = None
		for i in xrange(l, u):
			if abs(self.percentiles[i] - percentile) < tol:
				idx = i
				break

		if idx is None: idx = u
		if tol <= abstol or abs(self.percentiles[idx] - percentile) <= abstol:
			# return dose if available percentile bucket is close enough
			return self.doses[idx]
		else:
			# interpolate dose by interpolating percentiles if not close enough
			alpha = self.__interpolate_percentile(self.percentiles[i], 
				self.percentiles[i + 1], percentile)
			return alpha * self.doses[i] + (1 - alpha) * self.doses[i + 1]

	@property
	def mindose(self):
		""" TODO: docstring """
		if self.doses is None: return nan
		return self.doses[1]

	@property
	def maxdose(self):
		""" TODO: docstring """
		if self.doses is None: return nan
		return self.doses[-1]

	@property
	def stdev(self):
		""" TODO: docstring """
		if self.doses is None: return nan
		return stdev(self.doses[1:])
	
	def check_constraint(constraint_tuple):
		dose = constraint_tuple[0]
		direction = constraint_tuple[2]
		dose_achieved = self.dose_at_percentile(constraint_tuple[1])

		if direction == '<':
			status = dose_achieved <= dose
		else:
			status = dose_achieved >= dose

		return (status, dose_achieved)

	@property
	def plotting_data(self):
		""" TODO: docstring """
		return {'percentile' : self.percentiles, 'dose' : self.doses}

	@property
	def plotting_data_json_serializable(self):
		""" TODO: docstring """
		return {'percentile' : self.percentiles.round(self.WEB_DIGITS).tolist(),
			'dose' : self.doses.round(self.WEB_DIGITS).tolist()}