import cvxpy
import numpy as np
import numpy.linalg as LA

from cvxpy import *
from time import time
from multiprocessing import Process, Pipe

from data_utils import pad_matrix, check_dyn_matrices, health_prognosis
from mpc_funcs import *
from admm_spectral import step_spec

def build_dyn_prob_dose(A_list, patient_rx, T_recov = 0):
	T_treat = len(A_list)
	K, n = A_list[0].shape
	
	# Define variables.
	b = Variable((T_treat,n), pos = True, name = "beams")   # Beams.
	d = vstack([A_list[t]*b[t] for t in range(T_treat)])    # Doses.
	
	# Dose penalty function.
	obj = sum([dose_penalty(d[t], patient_rx["dose_weights"]) for t in range(T_treat)])
	
	# Additional dose constraints.
	# constrs = [b >= 0]
	constrs = []
	if "dose_constrs" in patient_rx:
		constrs += rx_to_constrs(vstack(d), patient_rx["dose_constrs"])
	
	prob = Problem(Minimize(obj), constrs)
	return prob, b, d

def build_dyn_prob_dose_period(A, patient_rx, T_recov = 0):
	K, n = A.shape
	
	# Define variables for period.
	b_t = Variable(n, pos = True, name = "beams")   # Beams.
	d_t = A*b_t
	
	# Dose penalty current period.
	obj = dose_penalty(d_t, patient_rx["dose_weights"])
	
	# Additional dose constraints in period.
	# constrs = [b >= 0]
	constrs = []
	if "dose_constrs" in patient_rx:
		constrs += rx_to_constrs(d_t, patient_rx["dose_constrs"])
	
	prob_t = Problem(Minimize(obj), constrs)
	return prob_t, b_t, d_t

def build_dyn_prob_health(F_list, G_list, r_list, h_init, patient_rx, T_treat, T_recov = 0):
	K = h_init.shape[0]
	
	# Define variables.
	h = Variable((T_treat+1,K), name = "health")   # Health statuses.
	# d = Variable((T_treat,K), pos = True, name = "doses")   # Doses.
	d = Variable((T_treat,K), pos = True, name = "doses", value = np.zeros((T_treat,K)))   # Doses.
	
	# Health penalty function.
	obj = sum([health_penalty(h[t+1], patient_rx["health_goal"], patient_rx["health_weights"]) for t in range(T_treat)])
	
	# Health dynamics for treatment stage.
	constrs = [h[0] == h_init]
	for t in range(T_treat):
		constrs.append(h[t+1] == F_list[t]*h[t] + G_list[t]*d[t] + r_list[t])
	
	# Additional health constraints.
	if "health_constrs" in patient_rx:
		constrs += rx_to_constrs(h[1:], patient_rx["health_constrs"])
	
	# Health dynamics for recovery stage.
	# TODO: Should we return h_r or calculate it later?
	if T_recov > 0:
		F_recov = F_list[T_treat:]
		r_recov = r_list[T_treat:]
		
		h_r = Variable((T_recov,K), name = "recovery")
		constrs_r = [h_r[0] == F_recov[0]*h[-1] + r_recov[0]]
		for t in range(T_recov-1):
			constrs_r.append(h_r[t+1] == F_recov[t+1]*h_r[t] + r_recov[t+1])
		
		# Additional health constraints during recovery.
		if "recov_constrs" in patient_rx:
			constrs_r += rx_to_constrs(h_r, patient_rx["recov_constrs"])
		constrs += constrs_r
	
	prob = Problem(Minimize(obj), constrs)
	return prob, h, d

def run_dose_worker(pipe, A, patient_rx, T_recov, rho_init, *args, **kwargs):
	# Spectral step size parameters.
	spectral = kwargs.pop("spectral", False)
	Tf_spc = kwargs.pop("Tf_spc", 2)
	
	# Construct proximal dose problem.
	prob_dose, b, d = build_dyn_prob_dose_period(A, patient_rx, T_recov)
	d_new = Parameter(d.shape, value = np.zeros(d.shape))
	l = Parameter(d.shape, value = np.zeros(d.shape))
	rho = Parameter(pos = True, value = rho_init)
	penalty = (rho/2)*sum_squares(d - d_new - l/rho)
	prox = prob_dose + Problem(Minimize(penalty))
	
	# ADMM loop.
	k = 0
	finished = False
	while not finished:
		# Compute and send d_t^k.
		prox.solve(*args, **kwargs)
		if prox.status not in ["optimal", "optimal_inaccurate"]:
			raise RuntimeError("Solver failed with status {0}".format(prox.status))
		pipe.send((d.value, prox.solver_stats.solve_time))
		
		# Receive \tilde d_t^k.
		d_new.value = pipe.recv()
		
		# Update and send l_t^^k.
		l.value += rho.value*(d_new.value - d.value)
		pipe.send(l.value)
		
		# Spectral step size update.
		if spectral and k % Tf_spc == 1:
			rho.value = pipe.recv()
		
		# Check if stopped.
		finished = pipe.recv()
		k = k + 1
	
	# Send final b_t^k and p_t^k.
	pipe.send(b.value)

def dynamic_treatment_admm(A_list, F_list, G_list, r_list, h_init, patient_rx, T_recov = 0, health_map = lambda h,t: h, partial_results = False, *args, **kwargs):
	T_treat = len(A_list)
	K, n = A_list[0].shape
	F_list, G_list, r_list = check_dyn_matrices(F_list, G_list, r_list, K, T_treat, T_recov)
	
	# Problem parameters.
	max_iter = kwargs.pop("max_iter", 1000) # Maximum iterations.
	rho_init = kwargs.pop("rho_init", 1/10) # Step size.
	eps_abs = kwargs.pop("eps_abs", 1e-6)   # Absolute stopping tolerance.
	eps_rel = kwargs.pop("eps_rel", 1e-8)   # Relative stopping tolerance.
	admm_verbose = kwargs.pop("admm_verbose", False)
	
	# Spectral step size paramaters.
	spectral = kwargs.pop("spectral", False)
	Tf_spc = kwargs.pop("Tf_spc", 2)
	eps_spc = kwargs.pop("eps_spc", 0.2)
	C_spc = kwargs.pop("C_spc", 1e10)
	
	# Validate parameters.
	if max_iter <= 0:
		raise ValueError("max_iter must be a positive integer.")
	if rho_init <= 0:
		raise ValueError("rho_init must be a positive scalar.")
	if eps_abs < 0:
		raise ValueError("eps_abs must be a non-negative scalar.")
	if eps_rel < 0:
		raise ValueError("eps_rel must be a non-negative scalar.")
	if Tf_spc <= 1:
		raise ValueError("Tf_spec must be an integer greater than 1.")
	if eps_spc < 0:
		raise ValueError("eps_spc must be a non-negative scalar.")
	if C_spc < 0:
		raise ValueError("C_spc must be a non-negative scalar.")
		
	# Set up dose workers.
	pipes = []
	procs = []
	for t in range(T_treat):
		rx_cur = rx_slice(patient_rx, t, t+1)
		
		local, remote = Pipe()
		pipes += [local]
		procs += [Process(target=run_dose_worker, args=(remote, A_list[t], rx_cur, T_recov, rho_init) + args, kwargs={**kwargs, "spectral": spectral, "Tf_spc": Tf_spc})]
		procs[-1].start()
	
	# Proximal health problem.
	prob_health, h, d_tld = build_dyn_prob_health(F_list, G_list, r_list, h_init, patient_rx, T_treat, T_recov)
	d_new = Parameter(d_tld.shape, value = np.zeros(d_tld.shape))
	l = Parameter(d_tld.shape, value = np.zeros(d_tld.shape))
	rho = Parameter(pos = True, value = rho_init)
	penalty = (rho/2)*sum_squares(d_tld - d_new + l/rho)
	prox = prob_health + Problem(Minimize(penalty))
	
	# ADMM loop.
	k = 0
	finished = False
	r_prim = np.zeros(max_iter)
	r_dual = np.zeros(max_iter)
	l_spc = l_hat_spc = d_new_spc = d_tld_spc = 0
	
	start = time()
	solve_time = 0
	while not finished:
		if admm_verbose and k % 10 == 0:
			print("Iteration:", k)
		
		# Save values from previous iteration.
		d_new_prev = d_new.value
		d_tld_prev = d_tld.value
		# d_tld_prev = np.zeros((T_treat,K)) if k == 0 else d_tld.value
		l_prev = l.value
		
		# Collect and stack d_t^k for t = 1,...,T.
		dt_update = [pipe.recv() for pipe in pipes]
		d_rows, d_times = map(list, zip(*dt_update))
		d_new.value = np.row_stack(d_rows)
		solve_time += np.max(d_times)
		
		# Compute and send \tilde d_t^k.
		prox.solve(*args, **kwargs)
		if prox.status not in ["optimal", "optimal_inaccurate"]:
			raise RuntimeError("Solver failed with status {0}".format(prox.status))
		solve_time += prox.solver_stats.solve_time
		for t in range(T_treat):
			pipes[t].send(d_tld[t].value)
		
		# Receive and update l_t^k for t = 1,...,T.
		l_rows = [pipe.recv() for pipe in pipes]
		l.value = np.row_stack(l_rows)
		
		# Spectral step size update.
		if spectral and k % Tf_spc == 1:
			# Compute \hat l_t^k for t = 1,...,T.
			l_hat_prev = np.zeros((T_treat,K)) if k == 1 else l_hat
			l_hat = l_prev + rho.value*(d_tld_prev - d_new.value)
			
			# Change in values from previous spectral update.
			dl = l.value - l_spc
			dl_hat = l_hat - l_hat_spc
			dH_hat = d_new.value - d_new_spc
			dG_hat = -d_tld.value + d_tld_spc
			
			# Update step size.
			rho.value = step_spec(rho.value, k, dl, dl_hat, dH_hat, dG_hat, eps_spc, C_spc)
			for t in range(T_treat):
				pipes[t].send(rho.value)
			
			# Save values from iteration k.
			l_spc = l_prev
			l_hat_spc = l_hat_prev
			d_new_spc = d_new_prev
			d_tld_spc = d_tld_prev
		
		# Calculate residuals.
		r_prim_mat = d_new.value - d_tld.value
		r_dual_mat = rho.value*(d_tld.value - d_tld_prev)
		r_prim[k] = LA.norm(r_prim_mat)
		r_dual[k] = LA.norm(r_dual_mat)
		
		# Check stopping criteria.
		eps_prim = eps_abs*np.sqrt(T_treat*K) + eps_rel*np.maximum(LA.norm(d_new.value), LA.norm(d_tld.value))
		eps_dual = eps_abs*np.sqrt(T_treat*K) + eps_rel*LA.norm(l.value)
		finished = (k + 1) >= max_iter or (r_prim[k] <= eps_prim and r_dual[k] <= eps_dual)
		k = k + 1
		for pipe in pipes:
			pipe.send(finished)
	
	# Receive final values of b_t^k for t = 1,...,T.
	b_rows = [pipe.recv() for pipe in pipes]
	b_val = np.row_stack(b_rows)
	
	[proc.terminate() for proc in procs]
	end = time()
	
	# Only used internally for calls in MPC.
	if partial_results:
		# TODO: Return primal/dual residuals as well?
		obj_pred = dyn_objective(d_tld.value, h.value, patient_rx).value
		return {"obj": obj_pred, "status": prox.status, "solve_time": solve_time, "beams": b_val, "doses": d_tld.value}
	
	# Construct full results.
	beams_all = pad_matrix(b_val, T_recov)
	doses_all = pad_matrix(d_tld.value, T_recov)
	# doses_all = pad_matrix((d_tld.value + d_new.value)/2, T_recov)
	G_list_pad = G_list + T_recov*[np.zeros(G_list[0].shape)]
	health_all = health_prognosis(h_init, T_treat + T_recov, F_list, G_list_pad, r_list, doses_all, health_map)
	obj = dyn_objective(d_tld.value, health_all[:(T_treat+1)], patient_rx).value
	return {"obj": obj, "status": prox.status, "num_iters": k, "total_time": end - start, "solve_time": solve_time, 
			"beams": beams_all, "doses": doses_all, "health": health_all, "primal": np.array(r_prim[:k]), "dual": np.array(r_dual[:k])}

def mpc_treatment_admm(A_list, F_list, G_list, r_list, h_init, patient_rx, T_recov = 0, health_map = lambda h,t: h, mpc_verbose = False, *args, **kwargs):
	T_treat = len(A_list)
	K, n = A_list[0].shape
	F_list, G_list, r_list = check_dyn_matrices(F_list, G_list, r_list, K, T_treat, T_recov)
	
	# Initialize values.
	beams = np.zeros((T_treat,n))
	doses = np.zeros((T_treat,K))
	solve_time = 0
	
	h_cur = h_init
	for t_s in range(T_treat):
		# Drop prescription for previous periods.
		rx_cur = rx_slice(patient_rx, t_s, T_treat)
		
		# Solve optimal control problem from current period forward.
		T_left = T_treat - t_s
		result = dynamic_treatment_admm(T_left*[A_list[t_s]], T_left*[F_list[t_s]], T_left*[G_list[t_s]], T_left*[r_list[t_s]], h_cur, rx_cur, T_recov, partial_results = True, *args, **kwargs)
		# result = dynamic_treatment_admm(A_list[t_s:], F_list[t_s:], G_list[t_s:], r_list[t_s:], h_cur, rx_cur, T_recov, partial_results = True, *args, **kwargs)
		solve_time += result["solve_time"]
		
		if mpc_verbose:
			print("Start Time:", t_s)
			print("Status:", result["status"])
			print("Objective:", result["obj"])
			print("Solve Time:", result["solve_time"])
		
		# Save beam, doses, and penalties for current period.
		status = result["status"]
		beams[t_s] = result["beams"][0]
		doses[t_s] = result["doses"][0]
		
		# Update health for next period.
		h_cur = health_map(h.value[1], t_s)
		# h_cur = health_map(F_list[t_s].dot(h_cur) + G_list[t_s].dot(doses[t_s]) + r_list[t_s], t_s)
	
	# Construct full results.
	beams_all = pad_matrix(beams, T_recov)
	doses_all = pad_matrix(doses, T_recov)
	G_list_pad = G_list + T_recov*[np.zeros(G_list[0].shape)]
	health_all = health_prognosis(h_init, T_treat + T_recov, F_list, G_list_pad, r_list, doses_all, health_map)
	obj_treat = dyn_objective(doses, health_all[:(T_treat+1)], patient_rx).value
	return {"obj": obj_treat, "status": status, "solve_time": solve_time, "beams": beams_all, "doses": doses_all, "health": health_all}
