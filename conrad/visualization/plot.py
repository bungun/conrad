"""
Dose volume histogram plotting utilities.

Provides :class:`DVHPlot` and :class:`CasePlotter` for conveniently
plotting DVH curve data generated by calling :func:`Case.plan`.

Attributes:
	PLOTTING_INSTALLED (:obj:`bool`): ``True`` if :mod:`matplotlib` is
		not available. If so, :class:`DVHPlot` and :class:`CasePlotter`
		types are replaced with lambdas that match the initialization
		argument signature and each yield ``None`` instead.

		If :mod:`matplotlib` *is* available, the :class:`DVHPlot` and
		:class:`CasePlotter` types are defined normally.

		This switch allows :mod:`conrad` to install, load and operate
		without Python plotting capabilities, and exempts
		:mod:`matplotlib` from being a load-time requirement.
"""
"""
Copyright 2016 Baris Ungun, Anqi Fu

This file is part of CONRAD.

CONRAD is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

CONRAD is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with CONRAD.  If not, see <http://www.gnu.org/licenses/>.
"""
from conrad.compat import *

from os import path
from math import ceil
from numpy import linspace
from os import getenv

from conrad.defs import module_installed
from conrad.optimization.history import RunRecord
from conrad.case import Case

# allow for CONRAD use without plotting by making visualization types
# optional
if module_installed('matplotlib'):
	PLOTTING_INSTALLED = True

	import matplotlib as mpl
	if getenv('DISPLAY') is not None:
		import matplotlib.pyplot as plt
		SHOW = plt.show
	else:
		mpl.use('Agg')
		import matplotlib.pyplot as plt
		SHOW = lambda : None

	from matplotlib.pyplot import get_cmap
	from matplotlib.colors import LinearSegmentedColormap
else:
	PLOTTING_INSTALLED = False


class ConradColorUtility(object):
	####################################################################
	# http://stackoverflow.com/questions/214359/
	# converting-hex-color-to-rgb-and-vice-versa/214657#214657
	@staticmethod
	def hex_to_rgb(value):
		value = value.lstrip('#')
		lv = len(value)
		return tuple(
			int(value[i:i + lv // 3], 16)
			for i in range(0, lv, lv // 3))

	@staticmethod
	def rgb_to_hex(rgb):
		return '#%02x%02x%02x' % rgb
	####################################################################
	@staticmethod
	def normalize_rgb(rgb):
		rgb_normalized = tuple(value / 255.0 for value in rgb[:3])
		if len(rgb) == 4:
			rgb_normalized += (rgb[-1],)
		return rgb_normalized

	@staticmethod
	def rgb_to_rgba(rgb):
		return rgb + (1,)

	@staticmethod
	def scale_rgb(rgb, factor=1.0):
		factor = max(min(float(factor), 1.0), 0.0)
		rgb_scaled = tuple(val * factor for val in rgb[:3])
		if len(rgb) == 4:
			rgb_scaled += (rgb[-1],)
		return rgb_scaled


class LineAesthetic(object):
	color_utils = ConradColorUtility()

	def __init__(self, aesthetic='dvh_curve'):
		self.style = '-'
		self.weight = 1
		self.marker = None
		self.markersize = 5
		self.fill = 'none'
		self.num_markers = 20
		self.alpha = 1.0
		self.color_attenuation = 1.0

		if 'dvh_constraint' in aesthetic:
			self.style = ''
			if aesthetic == 'dvh_constraint_large':
				self.markersize = 16
			else:
				self.markersize = 12
		elif 'slack' in aesthetic:
			self.alpha = 0.6

	def attenuate_color(self, color):
		if self.color_attenuation < 1.0:
			if isinstance(color, str):
				color = self.color_utils.normalize_rgb(
						self.color_utils.hex_to_rgb(color))
			color = self.color_utils.scale_rgb(color, self.color_attenuation)
		return color

	def plot_args(self, color, series_length=None):
		if isinstance(series_length, int):
			sample_factor = 1 + series_length // self.num_markers
		else:
			sample_factor = 1

		return {'linestyle': self.style,
				'linewidth': self.weight,
				'marker': self.marker,
				'markersize': self.markersize,
				'markevery': (1, sample_factor),
				'fillstyle': self.fill,
				'color': self.attenuate_color(color),
				'alpha': self.alpha,}


if not PLOTTING_INSTALLED:
	DVHSubplot = lambda arg1: None
	DVHPlot = lambda arg1, arg2: None
	CasePlotter = lambda arg1: None
else:
	class DVHSubplot(object):
		def __init__(self, subplot_axes, left=True, bottom=True):
			self.subplot_axes = subplot_axes
			self.__left = bool(left)
			self.__bottom = bool(bottom)

		@property
		def left(self):
			return self.__left

		@property
		def bottom(self):
			return self.__bottom

		def entitle(self, title):
			self.subplot_axes.set_title(title, loc='left',
					fontdict={'fontsize':12, 'fontweight':'bold'})

		def enable_legend(self):
			legend = self.subplot_axes.legend(loc='best')
			frame = legend.get_frame()
			frame.set_facecolor('1.0')
			frame.set_edgecolor('1.0')

		def format(self, xlimit, xlabel, ylabel, minimal_axes=True):
			ax = self.subplot_axes

			ax.set_xlim(0, xlimit)
			ax.set_ylim(0, 103)

			ax.spines['top'].set_visible(False)
			ax.spines['right'].set_visible(False)
			ax.tick_params(axis='x', bottom=True, top=False, direction='out')
			ax.tick_params(axis='y', left=True, right=False, direction='out')

			# put ticks and gridlines behind plotted curves
			ax.set_axisbelow(True)

			# offset spines
			for spine in ax.spines.values():
				spine.set_position(('outward', 5))

			if self.bottom:
				ax.set_xlabel(str(xlabel), fontsize=16)
			else:
				ax.tick_params(axis='x', bottom=False, labelbottom=False)
				ax.spines['bottom'].set_visible(False)

			if self.left:
				ax.set_ylabel(str(ylabel), fontsize=16)
			else:
				ax.tick_params(axis='y', left=not minimal_axes,
									labelleft=not minimal_axes)
				ax.spines['left'].set_visible(not minimal_axes)

			ax.grid(axis='y', color='0.9', linestyle='-', linewidth=1)


		def plot_dvh(self, data, color, label='_nolegend_',
					 aesthetic=None, **options):
			if aesthetic is None:
				aesthetic = LineAesthetic()

			for key, value in aesthetic.plot_args(color, data['dose'].size).items():
				options[key] = value

			dvh = self.subplot_axes.plot(
					data['dose'], data['percentile'], **options)[0]

			if label is None:
				label = '_nolegend_'
			dvh.set_label(label)

			return dvh

		def plot_rx(self, rx, color):
			self.subplot_axes.axvline(x=rx, linewidth=1.5, color=color,
					   		linestyle='dotted', label='_nolegend_')

		def plot_dose_constraints(self, data, color, large_markers=False):
			style_spec = 'dvh_constraint_large' if large_markers else \
						 'dvh_constraint_small'

			for constraint, _ in data:
				# TODO: What should we plot for other constraints
				# like mean, min, max, etc?
				if constraint['type'] is 'percentile':
					symbol = constraint['symbol']
					slack = abs(constraint['dose'][1] -
								constraint['dose'][0])

					aesthetic = LineAesthetic(aesthetic=style_spec)
					aesthetic.marker = symbol

					constraint_achieved = self.subplot_axes.plot(
							constraint['dose'][1],
							constraint['percentile'][1],
							label='_nolegend_',
							**aesthetic.plot_args(color))[0]

					if slack > 0.1:
						aesthetic = LineAesthetic(aesthetic=style_spec)
						aesthetic.marker = symbol
						aesthetic.alpha = 0.55

						constraint_requested = self.subplot_axes.plot(
								constraint['dose'][0],
								constraint['percentile'][0],
								label='_nolegend_',
								**aesthetic.plot_args(color))[0]

						aesthetic = LineAesthetic(aesthetic='slack')

						slack_line = self.subplot_axes.plot(
								constraint['dose'],
								constraint['percentile'],
								label='_nolegend_',
								**aesthetic.plot_args(color))[0]


	class DVHPlot(object):
		"""
		Tool for visualizing dose volume histograms.

		Figure contains :attr:`~DVHPlot.n_structures` dose volume
		histograms distributed among (:attr:`~DVHPlot.cols` by
		:attr:`~DVHPlot.rows`) subplots. This can be adjusted
		dynamically by changing the subplot indices assigned to each
		series.

		Attributes:
			figure (:class:`matplotlib.Figure`): Canvas for rendering
				dose volume histograms.
			subplots (:obj:`list` of :class:`matplotlib.AxesSubplot`):
				Subplots within canvas.
			n_structures (:obj:`int`): Number of structures for which to
				render DVH curves.
		"""

		def __init__(self, panels_by_structure, names_by_structure, layout='auto'):
			"""
			Initialize :class:`DVHPlot`.

			Initialize a :class:`matplotlib.Figure` as a blank canvas.
			Private dictionaries track panel (subplot index), series
			names, and series color assignments, all keyed by structure
			labels. Arguments set series names and subplot indices.

			Args:
				 panels_by_structure (:obj:`dict`): Dictionary of series
				 	subplot indices keyed by series (structure) labels.
				 names_by_structure: (:obj:`dict`): Dictionary of series
				 	names keyed by series (structure) labels.
				 layout: (:obj:`str`): Layout for subplots, used to set
				 	property :prop:`DVHPlot.layout`.
			"""
			self.figure = None
			self.subplots = {}
			self.__panel_subplots = {}
			self.__panels_by_structure = {}
			self.__names_by_structure = {}
			self.__colors_by_structure = {}
			self.__cols = 1
			self.__rows = 1
			self.__layout = 'auto'
			self.__legend_series = []
			self.__legend_names = []

			self.n_structures = len(panels_by_structure)
			self.series_names = names_by_structure
			self.layout = layout
			self.series_panels = panels_by_structure

			# set colors using default scheme to start
			self.autoset_series_colors()

		def clear(self):
			if self.figure is not None:
				plt.close(self.figure)
				self.figure = None
				self.subplots = {}
				self.__panel_subplots = {}
				self.__legend_names = []
				self.__legend_series = []

		def build(self):
			self.figure, subplots = plt.subplots(
					self.rows, self.cols, sharex='col', sharey='row')
			self.figure.set_size_inches(3.25 * self.cols, 3.25 * self.rows)

			# build label->subplot dictionary and panel->subplot dicitonary
			for label in self.series_panels:
				panel = self.series_panels[label]
				row = panel // self.cols
				col = panel % self.cols

				if self.n_panels == 1:
					subplot_axes = subplots
				elif self.rows == 1:
					subplot_axes = subplots[col]
				elif self.cols == 1:
					subplot_axes = subplots[row]
				else:
					subplot_axes = subplots[row, col]

				self.subplots[label] = DVHSubplot(
						subplot_axes, left=bool(col==0),
						bottom=bool(row==self.rows - 1))

				if not panel in self.__panel_subplots:
					self.__panel_subplots[panel] = self.subplots[label]

		@property
		def upper_right_subplot(self):
			return self.__panel_subplots[self.cols - 1]

		@staticmethod
		def panels_to_cols(n_panels):
			"""
			Convert number of panels to number of subplot columns.

			Used to standardize and balance subplot layout when using
			multiple structures. Prioritizes horizontal expansion over
			vertical expansion up to a maximum of 4 columns.

			Args:
				n_panels (:obj:`int`): number of subplot panels.

			Returns:
				:obj:`int`: number of subplot columns.

			Raises:
				None
			"""
			n_cols = 1
			if n_panels > 1:
				n_cols += 1
			if n_panels > 4:
				n_cols += 1
			if n_panels > 6:
				n_cols += 1
			return n_cols

		@property
		def rows(self):
			""" Number of subplot rows. """
			return self.__rows

		@property
		def cols(self):
			""" Number of subplot columns. """
			return self.__cols

		@property
		def n_panels(self):
			""" Total number of suplots. """
			return self.cols * self.rows

		@property
		def layout(self):
			"""
			Subplot layout: ``'auto'``, ``'vertical'``, or ``'horizontal'``.

			Raises:
				ValueError: If argument to setter is not one of the
					three accepted layout strings.
			"""
			return self.__layout

		@layout.setter
		def layout(self, layout):
			layout = str(layout)
			if layout not in ('auto', 'vertical', 'horizontal'):
				raise ValueError('argument `layout` must be one of:\n'
								 '-"auto"\n-"vertical"\n-"horizontal"')
			if layout != self.__layout:
				self.__layout = layout
				self.clear()
				self.calculate_panels()
				self.build()

		def calculate_panels(self, n_panels=None):
			n_panels = max(self.series_panels.values()) + 1
			if self.layout == 'vertical':
				self.__cols = 1
				self.__rows = n_panels
			elif self.layout == 'horizontal':
				self.__cols = n_panels
				self.__rows = 1
			else:  # if self.layout == 'auto':
				self.__cols = self.panels_to_cols(n_panels)
				self.__rows = int(ceil(float(n_panels) / self.__cols))

		@property
		def series_panels(self):
			"""
			Dictionary of series subplot indices keyed by series labels.
			"""
			return self.__panels_by_structure

		@series_panels.setter
		def series_panels(self, panels_by_structure):
			self.__panels_by_structure = {}
			for label in panels_by_structure:
				panel = panels_by_structure[label]
				self.__panels_by_structure[label] = panel

			self.calculate_panels()

		@property
		def series_names(self):
			""" Dictionary of series names keyed by series labels. """
			return self.__names_by_structure

		@series_names.setter
		def series_names(self, names_by_structure):
			self.__names_by_structure = {}
			for label in names_by_structure:
				self.__names_by_structure[label] = names_by_structure[label]

		@property
		def series_colors(self):
			""" Dictionary of series colors keyed by series labels. """
			return self.__colors_by_structure

		@series_colors.setter
		def series_colors(self, colors_by_structure):
			for label in colors_by_structure:
				self.__colors_by_structure[label] = colors_by_structure[label]

		def autoset_series_colors(self, structure_order_dict=None,
								  colormap='viridis'):
			"""
			Set series colors with (possibly default) :class:`LinearSegmentedColormap`.

			Args:
				structure_order_dict (:obj:`dict`, optional): Dictionary
					mapping series (i.e., structure) label keys to int
					values that give the rank-order of the series;
					permuting order allows different colors to be
					assigned to different series.
				colormap (:obj:`str`, optional) Assumed to be valid
					:mod:`matplotlib.pyplot` colormap name.

			Returns:
				None
			"""
			if isinstance(colormap, LinearSegmentedColormap):
				colors = listmap(colormap, linspace(
						0.1, 0.9, self.n_structures))
			else:
				cmap = get_cmap(colormap)
				colors = listmap(cmap, linspace(
						0.9, 0.1, self.n_structures))

			for idx, label in enumerate(self.series_panels.keys()):
				if structure_order_dict is not None:
					self.series_colors[label] = colors[structure_order_dict[label]]
				else:
					self.series_colors[label] = colors[idx]

		@staticmethod
		def get_max_dose(data, suppress_constraints=False):
			xmax = 0
			for series in data.values():
				xmax = max(xmax, series['curve']['dose'][-1])
				if not suppress_constraints:
					for constraint in series['constraints']:
						xmax = max(xmax, constraint[1]['dose'][0])
			return xmax

		def entitle_panel(self, panel, title):
			self.__panel_subplots[panel].entitle(title)

		def enable_meta_legend(self, series, names, legend_alignment=None,
							   legend_coordinates=None, **legend_options):
			fancybox = bool(legend_options.pop('fancybox', False))
			shadow = bool(legend_options.pop('shadow', True))
			legend_border = bool(legend_options.pop('legend_border', True))
			fontsize = int(legend_options.pop('fontsize', 12))

			legend_args = {
				'ncol':1,
				'loc':'upper right',
				'columnspacing':1.0,
				'labelspacing':0.0,
				'handletextpad':0.0,
				'handlelength':2.0,
				'fontsize':fontsize,
				'fancybox':fancybox,
				'shadow':shadow,
			}
			if legend_alignment is not None:
				legend_args['loc'] = legend_alignment
			if legend_coordinates is not None:
				legend_args['bbox_to_anchor'] = legend_coordinates
			legend = self.figure.legend(series, names, **legend_args)
			if not legend_border:
				frame = legend.get_frame()
				frame.set_edgecolor('1.0')
				frame.set_facecolor('1.0')

		def plot_structure_data(self, label, data, aesthetic=None,
								large_markers=False,
								suppress_constraints=False, suppress_rx=False,
								self_title=False, add_to_legend=True,
								**options):
			add_to_legend = bool(add_to_legend) and not self_title

			structure_name = data['name']
			series_name = self.series_names[label] if add_to_legend else None
			color = self.series_colors[label]
			subplot = self.subplots[label]


			dvh = subplot.plot_dvh(data['curve'], color, aesthetic=aesthetic,
						  		   label=series_name, **options)
			if add_to_legend:
				self.__legend_series.append(dvh)
				self.__legend_names.append(series_name)

			if not suppress_constraints:
				subplot.plot_dose_constraints(data['constraints'], color,
											  large_markers=large_markers)

			if data['rx'] > 0 and not suppress_rx:
				subplot.plot_rx(data['rx'], color)

			if self_title:
				subplot.entitle(structure_name)



		def plot_virtual(self, series_names, series_aesthetics,
						 legend_alignment=None, legend_coordinates=None,
						 **legend_options):
			#subplot or upper right panel
			upper_right = self.upper_right_subplot
			series = []

			for name, aesthetic in zip(series_names, series_aesthetics):
				virtual_line = mpl.lines.Line2D(
						[], [], label=name, **aesthetic.plot_args('#222222'))
				series.append(virtual_line)

			self.enable_meta_legend(series, series_names,
									legend_alignment=legend_alignment,
									legend_coordinates=legend_coordinates,
									**legend_options)

		def plot(self, plot_data, show=False, clear=True, xmax=None,
				 legend=True, title=None, self_title_subplots=False,
				 large_markers=False, suppress_constraints=False,
				 x_label='Dose (Gy)', y_label='Percentile',
				 legend_coordinates=None, legend_alignment=None,
				 aesthetic=None, minimal_axes=True, **options):
			"""
			Plot ``plot_data`` to the object's :class:`matplotlib.Figure`.

			The input ``plot_data`` should a :obj:`dict` with the
			following scheme::

				{
					series_label_1: {
						curve: {
							dose: numpy.ndarray, # (x data)
							percentile: numpy.ndarray # (y data)
						},
						constraints:[
							{
								dose: [float, float], #(value, value +/- slack)
							  	percentile: [float, float],
							  	symbol: char #(i.e., '<' or '>')
							 }, ..
						]
					},
					..
				}

			Args:
				plot_data (:obj:`dict`) Collection of DVH curves, keyed
					by structure/series label, with format specified
					above.
				show (:obj:`bool`, optional): Show
					:class:`matplotlib.Figure` canvas after
					``plot_data`` elements are drawn.
				clear (:obj:`bool`, optional): Clear
					:class:`matplotlib.Figure` before ``plot_data``
					elements are drawn.
				xmax (:obj:`float`, optional): Upper limit for x-axis
					set to this value if provided. Otherwise, upper
					limit set to 110% of largest dose encountered in
					``plot_data``.
				legend (optional): Enable legend in
					:class:`matplotlib.Figure`. Set overall legend if
					value is ``True``, set legend per subplot if value
					is ``'each'``, set legend in upper-right-most
					subplot if value is ``'upper_right'``.
				title (:obj:`str`, optional): Contents drawn as title of
					:class:`matplotlib.Figure`.
				large_markers (:obj:`bool`, optional): Draw dose volume
					constraints with larger size markers.
				suppress_constraints (:obj:`bool`, optional): Suppress
					rendering of dose volume constraints.
				x_label (:obj:`str`, optional): x-axis label.
				y_label (:obj:`str`, optional): y-axis label.
				legend_coordinates (:obj:`list`, optional): Position, as
				 	(x,y)-coordinates, of legend anchor relative to
				 	figure; passed as kewyword argument ``bbox_to_anchor``
				 	in  :meth:`matplotlib.Figure.legend`.
				legend_alignment (:obj:`str`, optional): String defining
					alignment of legend relative to anchor, passed as
					keyword argument ``loc`` in
					:meth:`matplotlib.Figure.legend`.
				**options: Arbitrary keyword arguments, passed to
					:meth:`matplotlib.Figure.plot`.

			Returns:
				None
			"""
			if clear:
				self.clear()

			# get figure, subplot axes,
			if self.figure is None:
				self.build()

			# get x-axis limits
			max_dose = self.get_max_dose(
					plot_data, suppress_constraints=suppress_constraints)
			xlim_upper = xmax if xmax is not None else 1.1 * max_dose

			# plot title
			if title is not None:
				self.figure.suptitle(title)

			# format subplots:
			counter = 0
			for subplot in self.subplots.values():
				counter += 1
				subplot.format(xlim_upper, x_label, y_label,
							   minimal_axes=minimal_axes)

			self.figure.subplots_adjust(left=0.09, bottom=0.1, right=0.99,
										top=0.99, wspace=0.1, hspace=0.15)

			# plot data
			for label, data in plot_data.items():
				self.plot_structure_data(
						label, data, aesthetic=aesthetic,
						large_markers=large_markers, add_to_legend=legend,
						suppress_constraints=suppress_constraints,
						self_title=self_title_subplots, **options)


			# draw legends, per subplot or overall
			for subplot in self.subplots.values():
				subplot_legend = legend == 'each'
				subplot_legend |= bool(legend == 'upper_right' and
									   subplot == self.upper_right_subplot)

				if subplot_legend:
					subplot.enable_legend()

			if bool(isinstance(legend, bool) and legend and
					len(self.__legend_series) > 0):
				self.enable_meta_legend(
						self.__legend_series, self.__legend_names,
						legend_alignment=legend_alignment,
						legend_coordinates=legend_coordinates, **options)

			if show:
				self.show()

		def show(self):
			SHOW()

		def save(self, filepath, overwrite=True, verbose=False):
			"""
			Save the object's current plot to ``filepath``.

			Args:
				filepath (:obj:`str`): Specify path to save plot.
				overwrite (bool):, Allow overwrite of file at
					``filepath``if ``True``.
				verbose (:obj:`bool`): Print confirmation of save if
					``True``.

			Returns:
				None

			Raises:
				ValueError: If ``filepath`` does not exist *or* is an
					existing file and flag ``overwrite`` is ``False``.
				RuntimeError: If save fails for any other reason.
			"""
			filepath = path.abspath(filepath)
			directory = path.dirname(filepath)
			if not path.isdir(path.dirname(filepath)):
				raise ValueError(
						'argument "filepath" specified with invalid'
						'directory')
			elif not overwrite and path.exists(filepath):
				raise ValueError(
						'argument "filepath" specifies an existing file'
						'and argument "overwrite" is set to False')
			else:
				try:
					if verbose:
						print("SAVING TO ", filepath)
					self.figure.savefig(filepath, bbox_inches='tight')
				except:
					raise RuntimeError(
							'could not save plot to file: {}'.format(filepath))

		def __del__(self):
			"""
			Close object's :class:`matplotlib.Figure` when out of scope.
			"""
			self.clear()

	class CasePlotter(object):
		"""
		Wrap :class:`DVHPlot` for visualizing treatment plan data.

		Attributes:
			dvh_plot (:class:`DVHPlot`): Dose volume histogram plot.

		Examples:
			>>> # intialize based on an existing :class:`Case` object "case"
			>>> plotter = CasePlotter(case)

			>>> # form treatment plan with case
			>>> _, run = case.plan(**args)

			>>> # plot the output emitted by the case.plan() call
			>>> plotter.plot(run, **options)
		"""

		def __init__(self, case, subset=None):
			"""
			Initialize :class:`CasePlotter`.

			Use structure information from ``case`` to initialize a
			:class:`DVHPlot` object with the names and labels of each
			structure associated with the case.

			Args:
				case (:class:`Case`): Treatment planning case to use as
					basis for configuring object's :class:`DVHPlot`
				subset (:obj:`list`, optional): List of labels of
					structures to use in a restricted plotting context.

			Raises:
				TypeError: If argument is not of type :class:`Case`
			"""
			if not isinstance(case, Case):
				TypeError('argument "case" must be of type conrad.Case')

			if subset is None:
				subset = case.anatomy.label_order

			# plot setup
			panels_by_structure = {label: 1 for label in subset}
			names_by_structure = {
					label: case.anatomy[label].name for label in subset}
			self.dvh_plot = DVHPlot(panels_by_structure, names_by_structure)
			self.__labels = {}
			self.__grouping = 'together'
			for s in case.anatomy:
				if s.label in subset:
					self.__labels[s.label] = s.label
					self.__labels[s.name] = s.label

		def label_is_valid(self, label):
			return label in self.__labels

		def set_display_groups(self, grouping='together', group_list=None):
			"""
			Specify structure-to-panel assignments for display.

			Args:
				grouping (:obj:`str`, optional): Should be one of
					'together', 'separate', or 'list'. If 'together',
					all curves plotted on single panel. If 'separate',
					each curve plotton on its own panel. If 'list',
					curves grouped according to ``group_list``.
				group_list (:obj:`list` of :obj:`tuple`, optional): If
						provided, each element of the i-th :obj:`tuple`
						is assumed to be a valid structure label, and
						the DVH curve for the corresponding structure is
						assigned to panel i.

			Returns:
				None

			Raises:
				TypeError: If ``grouping`` is not a :obj:`str` or
					members of ``group_list`` are not each a
					:obj:`tuple`.
				ValueError: If ``grouping`` is not one of ('together',
					separate', 'list'); *or* if each label in each tuple
					in ``group_list`` does not correspond to a structure
					label in the case used to initialize this
					:class:`CasePlotter`.
			"""

			if not isinstance(grouping, str):
				raise TypeError('argument "grouping" must be of type {}'
								''.format(str))
			if grouping not in ('together', 'separate', 'list'):
				raise ValueError('argument "grouping" must be one of '
								 'the following: ("together", '
								 '"separate", or "list")')

			if grouping == 'together':
				for key in self.dvh_plot.series_panels:
					self.dvh_plot.series_panels[key] = 0
			elif grouping == 'separate':
				for i, key in enumerate(self.dvh_plot.series_panels):
					self.dvh_plot.series_panels[key] = i
			elif grouping == 'list':
				valid = isinstance(group_list, list)
				valid &= all(map(lambda x: isinstance(x, tuple), group_list))
				if valid:
					for i, group in enumerate(group_list):
						for label in group:
							if self.label_is_valid(label):
								self.dvh_plot.series_panels[
										self.__labels[label]] = i
							else:
								raise ValueError(
										'specified label {} in tuple {} '
										'does not correspond to any '
										'known structure labels in the '
										'current case'
										''.format(label, group))
				else:
					raise TypeError('argument "group_list" must be a {} '
									'of {}s'.format(list, tuple))

			self.dvh_plot.clear()
			self.__grouping = grouping
			self.dvh_plot.calculate_panels()
			self.dvh_plot.build()

		def plot(self, data, second_pass=False, show=False, clear=True,
				 subset=None, plotfile=None, aesthetic=None, **options):
			"""
			Plot dose volume histograms from argument `data`.

			Args:
				data (:obj:`dict`, or :class:`RunRecord`): Used to build
					the DVH curves. Assumed to be compatible with the
					`Case` used to initialize this object.
				second_pass (:obj:`bool`, optional): Plot data from
					second planning pass when ``True`` and ``data`` is a
					:class:`RunRecord`.
				show (:obj:`bool`, optional): Show figure after drawing.
				clear (:obj:`bool`, optional): Clear figure before
					rendering data in ``data``.
				subset (:obj:`list` or :obj:`tuple`, optional): Specify
					labels of DVH curves to be plotted; others are
					suppressed. All structures' DVH curves are plotted
					by default.
				plotfile (:obj:`str`, optional): Passed to to the
					:class:`DVHPlot` as a target filepath to save the
					drawn plot.
				aesthetic (:class:`LineAesthetic`, optional): Passed to
					:meth:`~DVHPlot.plot` to apply to the DVH curves.
				**options: Arbitrary keyword arguments passed through to
					:meth:`~DVHPlot.plot`.

			Returns:
				None

			Raises:
				TypeError: If ``subset`` is specified but not a
					:obj:`list` or :obj:`tuple`.
				KeyError: If ``subset`` is specified but contains items
					that are not recognized as valid structure labels.
			"""
			if plotfile is None:
				plotfile = options.pop('file', None)
			if isinstance(data, RunRecord):
				if second_pass and data.plotting_data['exact'] is not None:
					data = data.plotting_data['exact']
				else:
					data = data.plotting_data[0]
			data_ = data

			# filter data to only plot DVH for structures with requested labels
			if subset is None:
				data = data_
			else:
				if not isinstance(subset, (list, tuple)):
					raise TypeError('argument "subset" must be of type {} or '
									'{}'.format(list, tuple))
				if not all([label in data_.keys() for label in subset]):
					raise KeyError('argument "subset" specifies an invalid '
								   'structure label')
				data = {}
				for label in subset:
					data[label] = data_[label]


			if 'self_title_subplots' in options:
				options['self_title_subplots'] &= self.__grouping == 'separate'

			self.dvh_plot.plot(data, clear=clear, aesthetic=aesthetic,
							   **options)
			if show:
				self.dvh_plot.show()
			if plotfile is not None:
				self.dvh_plot.save(plotfile)

		def plot_multi(self, data, run_names, reference_data=None,
					   reference_name='reference', show=False, clear=True,
				 	   subset=None, plotfile=None, layout='auto',
				 	   vary_markers=True, vary_marker_sizes=False,
				 	   marker_size_increasing=True,
				 	   universal_marker=None, vary_line_weights=False,
				 	   vary_line_colors=False, vary_line_styles=False,
				 	   darken_reference=True, **options):
			"""
			Plot data from multiple runs.

			Args:
				data (:obj:`list` of :class:`RunRecord` or :obj:`dict`):
				reference_data (:class:`RunRecord` or :obj:`dict`, optinal):
				varied_property (:obj:`str`, optional): Should be one of
					``'linestyle'``, ``'symbol'``, ``'color'``
			"""
			n_compared = len(data) + int(reference_data is not None)
			run_aesthetics = [LineAesthetic() for i in xrange(n_compared)]

			line_styles = ['-', '-.', '--', ':']
			if len(data) > 4 and vary_line_styles:
				vary_markers = True

			vary_markers &= universal_marker is None
			vary_marker_sizes |= universal_marker is not None
			marker_styles = ['o', 's', '^']
			fill_styles = ['none', 'full']
			if len(data) > 6 and vary_markers:
				vary_line_styles = True

			weight_step = 0.5
			min_weight = 0.5
			max_weight = 2.0
			if vary_line_weights:
				max_weight = max(
						max_weight, min_weight + weight_step * n_compared)

			max_attenuation = 0.7
			min_attentuation = 1.0
			attenuation_step = -0.5 / n_compared

			# set layout
			self.dvh_plot.layout = layout

			# set aesthetics for each data series
			for i, run_data in enumerate(data):
				if vary_line_styles:
					run_aesthetics[i].style = line_styles[i % 4]
				if universal_marker is not None:
					run_aesthetics[i].marker = universal_marker
				if vary_markers:
					run_aesthetics[i].marker = marker_styles[i % 3]
					run_aesthetics[i].fill = fill_styles[i % 2]
				if vary_marker_sizes:
					if marker_size_increasing:
						run_aesthetics[i].markersize = 4 + 2 * i
					else:
						run_aesthetics[i].markersize = 4 + 2 * (n_compared - 1 - i)
				if vary_line_weights:
					run_aesthetics[i].weight = min_weight + i * weight_step
				if vary_line_colors:
					run_aesthetics[i].color_attenuation = 1.0 - i * attenuation_step

			# set reference aesthetics
			if reference_data is not None:
				data.append(reference_data)
				run_names.append(str(reference_name))

				run_aesthetics[-1].weight = max_weight
				if darken_reference:
					run_aesthetics[-1].color_attenuation = max_attenuation


			options['xmax'] = max([self.dvh_plot.get_max_dose(d) for d in data])

			# plot each data series
			if clear:
				self.dvh_plot.clear()

			for i in xrange(n_compared):
				if i == 0:
					options['self_title_subplots'] = True

				self.plot(data[i], clear=False, subset=subset, legend=False,
						  aesthetic=run_aesthetics[i], **options)

			# plot legend
			self.dvh_plot.plot_virtual(run_names, run_aesthetics)

			if show:
				self.dvh_plot.show()
			if plotfile is not None:
				self.dvh_plot.save(plotfile)
