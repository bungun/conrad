"""
Dose volume histogram plotting utilities.

Provides :class:`DVHPlot` and :class:`CasePlotter` for conveniently
plotting DVH curve data generated by calling :func:`Case.plan`.

Attributes:
	PLOTTING_INSTALLED (:obj:`bool`): ``True`` if :mod:`matplotlib` is
		not available. If so, :class:`DVHPlot` and :class:`CasePlotter`
		types are replaced with lambdas that match the initialization
		argument signature and each yield ``None`` instead.

		If :mod:`matplotlib` *is* available, the :class:`DVHPlot` and
		:class:`CasePlotter` types are defined normally.

		This switch allows :mod:`conrad` to install, load and operate
		without Python plotting capabilities, and exempts
		:mod:`matplotlib` from being a load-time requirement.
"""
"""
Copyright 2016 Baris Ungun, Anqi Fu

This file is part of CONRAD.

CONRAD is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

CONRAD is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with CONRAD.  If not, see <http://www.gnu.org/licenses/>.
"""
from conrad.compat import *

from os import path
from math import ceil
from numpy import linspace
from os import getenv

from conrad.defs import module_installed
from conrad.optimization.history import RunRecord
from conrad.case import Case

# allow for CONRAD use without plotting by making visualization types
# optional
if module_installed('matplotlib'):
	PLOTTING_INSTALLED = True

	import matplotlib as mpl
	if getenv('DISPLAY') is not None:
		import matplotlib.pyplot as plt
		SHOW = plt.show
	else:
		mpl.use('Agg')
		import matplotlib.pyplot as plt
		SHOW = lambda : None

	from matplotlib.pyplot import get_cmap
	from matplotlib.colors import LinearSegmentedColormap
else:
	PLOTTING_INSTALLED = False

class ConradColorUtility(object):
	####################################################################
	# http://stackoverflow.com/questions/214359/
	# converting-hex-color-to-rgb-and-vice-versa/214657#214657
	def to_rgb(self, color):
		"""
		Convert any :mod:`matplotlib` color to RGB tuple.
		"""
		return mpl.colors.colorConverter.to_rgb(color)

	def to_hex(self, color):
		"""
		Convert any :mod:`matplotlib` color to HTML hex string.
		"""
		return '#%02x%02x%02x' % self.to_rgb(color)
	####################################################################

	def scale_rgb(self, color, factor=1.0):
		"""
		Convert any :mod:`matplotlib` color to RGBA tuple and scale all
		color entries of tuple ``rgb`` by ``factor``.

		Args:
			rgb (:obj:`tuple`): RGB or RGBA tuple.
			factor (:obj:`float`, optional): Scalar in [0, 1].

		Returns:
			:obj:`tuple`: Scaled version of input RGB or RGBA tuple.
		"""
		rgba = mpl.colors.colorConverter.to_rgba(color)

		factor = max(min(float(factor), 1.0), 0.0)
		if factor == 1.0:
			return rgba

		rgba_scaled = tuple(val * factor for val in rgba[:3])
		rgba_scaled += (rgba[-1],)
		return rgba_scaled


class LineAesthetic(object):
	"""
	Abstraction of :mod:`matplotlib` line styling, intended for use with
	a family of lines with all style aspects shared *except* color.

	The :class:`LineAesthetic` does not specify a color; it must be
	paired with a color to create a full specification that can be
	applied to :mod:`matplotlib` plotting methods.

	Attributes:
		style (:obj:`str`): Line style. Must be compatible with styles
			specified in :mod:`matplotlib.lines`.
		weight (:obj:`float`): Line weight.
		marker (:obj:`str` or ``None``): Marker style to apply to line.
		fill (:obj:`str`): Fill style to apply to line's markers.
		num_markers (:obj:`int`): Number of markers to draw when
			rendering line.
		alpha (:obj:`float`): Value in [0, 1] specifying opacity of
			line.
		color_attenuation (:obj:`float`): Value in [0, 1] (recommended
			range: [0.7, 1]) specifying attenuation of colors paired
			with this :class:`LineAesthetic`. ``1.0`` yields original
			color; ``0.0`` yields black.
	"""
	color_utils = ConradColorUtility()

	def __init__(self, aesthetic='dvh_curve'):
		self.style = '-'
		self.weight = 1.0
		self.marker = None
		self.markersize = 5.0
		self.fill = 'none'
		self.num_markers = 20
		self.alpha = 1.0
		self.color_attenuation = 1.0

		if 'dvh_constraint' in aesthetic:
			self.style = ''
			if aesthetic == 'dvh_constraint_large':
				self.markersize = 16
			else:
				self.markersize = 12
		elif 'slack' in aesthetic:
			self.alpha = 0.6

	def attenuate_color(self, color):
		r"""
		Return a weighted average of black and specified color.

		Let :math:`\alpha` be the attenuation specified by
		attr:`LineAesthetic.color_attenuation`, :math:`c` be the vector
		representation of the input color ``color`` (e.g., in RGB),
		where :math:`0` is black. Then, the returned color is
		:math:`\alpha c`

		Args:
			color: Any :mod:`matplotlib`-compatible color description,
				base color to attenuate.
		"""
		return self.color_utils.scale_rgb(color, self.color_attenuation)

	def plot_args(self, color, series_length=None):
		"""
		Generate dictionary of keyword arguments representing line
		aesthetic for :mod:`matplotlib` methods.

		Args:
			color: Any :mod:`matplotlib`-compatible color description,
				pairs with line aesthetic data to create style keywords.
			series_length (:obj:`int`, optional): If provided, used to
				calculate sampling frequency of markers, based on total
				number of desired markers as specified by
				attr:`LineAesthetic.num_markers`.

		Returns:
			Dictionary of keyword arguments compatible with
			:meth:`matplotlib.figure.Figure.plot()`
			or, equivalently, initializer of
			:class:`matplotlib.lines.Line2D`.
		"""
		if isinstance(series_length, int):
			sample_factor = 1 + series_length // self.num_markers
		else:
			sample_factor = 1

		return {'linestyle': self.style,
				'linewidth': self.weight,
				'marker': self.marker,
				'markersize': self.markersize,
				'markevery': (1, sample_factor),
				'fillstyle': self.fill,
				'color': self.attenuate_color(color),
				'alpha': self.alpha,}


if not PLOTTING_INSTALLED:
	DVHSubplot = lambda arg1: None
	DVHPlot = lambda arg1, arg2: None
	CasePlotter = lambda arg1: None
else:
	class DVHSubplot(object):
		def __init__(self, subplot_axes, left=True, bottom=True):
			self.subplot_axes = subplot_axes
			self.__left = bool(left)
			self.__bottom = bool(bottom)

		@property
		def left(self):
			return self.__left

		@property
		def bottom(self):
			return self.__bottom

		def entitle(self, title):
			self.subplot_axes.set_title(title, loc='left',
					fontdict={'fontsize':12, 'fontweight':'bold'})

		def enable_legend(self):
			legend = self.subplot_axes.legend(loc='best')
			frame = legend.get_frame()
			frame.set_facecolor('1.0')
			frame.set_edgecolor('1.0')

		def format(self, xlimit, xlabel, ylabel, minimal_axes=True):
			ax = self.subplot_axes

			ax.set_xlim(0, xlimit)
			ax.set_ylim(0, 103)

			ax.spines['top'].set_visible(False)
			ax.spines['right'].set_visible(False)
			ax.tick_params(axis='x', bottom=True, top=False, direction='out')
			ax.tick_params(axis='y', left=True, right=False, direction='out')

			# put ticks and gridlines behind plotted curves
			ax.set_axisbelow(True)

			# offset spines
			for spine in ax.spines.values():
				spine.set_position(('outward', 5))

			if self.bottom:
				xlabel_size = 16 - 2 * (len(xlabel) > 10) - 2 * (len(xlabel) > 25)
				ax.set_xlabel(str(xlabel), fontsize=xlabel_size)
			else:
				ax.tick_params(axis='x', bottom=False, labelbottom=False)
				ax.spines['bottom'].set_visible(False)

			if self.left:
				ylabel_size = 16 - 2 * (len(ylabel) > 10) - 2 * (len(ylabel) > 25)
				ax.set_ylabel(str(ylabel), fontsize=ylabel_size)
			else:
				ax.tick_params(axis='y', left=not minimal_axes,
									labelleft=not minimal_axes)
				ax.spines['left'].set_visible(not minimal_axes)

			ax.grid(axis='y', color='0.9', linestyle='-', linewidth=1)


		def plot_dvh(self, data, color, series_label='_nolegend_',
					 aesthetic=None, **options):
			"""
			TODO: DESCRIPTION

			Args:
				data: DESCRIPTION
				color: DESCRIPTION
				series_label (:obj:`str`, optional): DESCRIPTION
				aesthetic (:class:`LineAesthetic`, optional): DESCRIPTION
				**options: Keyword arguments passed to initializer for
				:class:`matplotlib.lines.Line2D`.

			Returns:
				None
			"""
			if aesthetic is None:
				aesthetic = LineAesthetic()

			for key, value in aesthetic.plot_args(color, data['dose'].size).items():
				options[key] = value

			dvh = self.subplot_axes.plot(
					data['dose'], data['percentile'], **options)[0]

			if series_label is None:
				series_label = '_nolegend_'
			dvh.set_label(series_label)

			return dvh

		def plot_rx(self, rx, color):
			"""
			TODO: DESCRIPTION

			Args:
				rx: DESCRIPTION
				color: DESCRIPTION

			Returns:
				None
			"""
			self.subplot_axes.axvline(x=rx, linewidth=1.5, color=color,
					   		linestyle='dotted', label='_nolegend_')

		def plot_dose_constraints(self, data, color, large_markers=False):
			"""
			TODO: DESCRIPTION

			Args:
				data: DESCRIPTION
				color: DESCRIPTION
				large_markers (:obj:`bool`, optional): DESCRIPTION

			Returns:
				None
			"""
			style_spec = 'dvh_constraint_large' if large_markers else \
						 'dvh_constraint_small'

			for constraint, _ in data:
				# TODO: What should we plot for other constraints
				# like mean, min, max, etc?
				if constraint['type'] is 'percentile':
					symbol = constraint['symbol']
					slack = abs(constraint['dose'][1] -
								constraint['dose'][0])

					aesthetic = LineAesthetic(aesthetic=style_spec)
					aesthetic.marker = symbol

					constraint_achieved = self.subplot_axes.plot(
							constraint['dose'][1],
							constraint['percentile'][1],
							label='_nolegend_',
							**aesthetic.plot_args(color))[0]

					if slack > 0.1:
						aesthetic = LineAesthetic(aesthetic=style_spec)
						aesthetic.marker = symbol
						aesthetic.alpha = 0.55

						constraint_requested = self.subplot_axes.plot(
								constraint['dose'][0],
								constraint['percentile'][0],
								label='_nolegend_',
								**aesthetic.plot_args(color))[0]

						aesthetic = LineAesthetic(aesthetic='slack')

						slack_line = self.subplot_axes.plot(
								constraint['dose'],
								constraint['percentile'],
								label='_nolegend_',
								**aesthetic.plot_args(color))[0]


	class DVHPlot(object):
		"""
		Tool for visualizing dose volume histograms.

		Figure contains :attr:`~DVHPlot.n_structures` dose volume
		histograms distributed among (:attr:`~DVHPlot.cols` by
		:attr:`~DVHPlot.rows`) subplots. This can be adjusted
		dynamically by changing the subplot indices assigned to each
		series.

		Attributes:
			figure (:class:`matplotlib.Figure`): Canvas for rendering
				dose volume histograms.
			subplots (:obj:`dict` of :class:`DVHSubplot`): Dictionary of
				handles to subplots within canvas, keyed by structure
				label.
			n_structures (:obj:`int`): Number of structures for which to
				render DVH curves.
		"""

		def __init__(self, panels_by_structure, names_by_structure, layout='auto'):
			"""
			Initialize :class:`DVHPlot`.

			Initialize a :class:`matplotlib.Figure` as a blank canvas.
			Private dictionaries track panel (subplot index), series
			names, and series color assignments, all keyed by structure
			labels. Arguments set series names and subplot indices.

			Args:
				 panels_by_structure (:obj:`dict`): Dictionary of series
				 	subplot indices keyed by series (structure) labels.
				 names_by_structure: (:obj:`dict`): Dictionary of series
				 	names keyed by series (structure) labels.
				 layout: (:obj:`str`): Layout for subplots, used to set
				 	property attr:`DVHPlot.layout`.
			"""
			self.figure = None
			self.subplots = {}
			self.__panel_subplots = {}
			self.__panels_by_structure = {}
			self.__names_by_structure = {}
			self.__colors_by_structure = {}
			self.__cols = 1
			self.__rows = 1
			self.__layout = 'auto'
			self.__legend_series = []
			self.__legend_names = []

			self.n_structures = len(panels_by_structure)
			self.series_names = names_by_structure
			self.layout = layout
			self.series_panels = panels_by_structure

			# set colors using default scheme to start
			self.autoset_series_colors()

		def clear(self):
			"""
			Closes the :mod:`matplotlib` figure at `DVHPlot.figure`,
			clears the dictionary of subplot handles `DVHPlot.subplots`.

			Returns:
				None
			"""
			if self.figure is not None:
				plt.close(self.figure)
				self.figure = None
				self.subplots = {}
				self.__panel_subplots = {}
				self.__legend_names = []
				self.__legend_series = []

		def build(self):
			"""
			Build :attr:`DVHPlot.figure` with subplots laid out in a
			:attr:`DVHPlot.rows` by :attr:`DVHPlot.cols` grid.

			Handles to the subplots are stored as a dictionary (keyed by
			structure label) in the field :attr:`DVHPlot.subplots`.

			Returns:
				None
			"""
			self.figure, subplots = plt.subplots(
					self.rows, self.cols, sharex='col', sharey='row')
			self.figure.set_size_inches(3.25 * self.cols, 3.25 * self.rows)

			# build label->subplot and panel->subplot dicitonaries,
			# given geometric arrangement and label->panel dictionary.
			for label in self.series_panels:
				panel = self.series_panels[label]
				row = panel // self.cols
				col = panel % self.cols

				if self.n_panels == 1:
					subplot_axes = subplots
				elif self.rows == 1:
					subplot_axes = subplots[col]
				elif self.cols == 1:
					subplot_axes = subplots[row]
				else:
					subplot_axes = subplots[row, col]

				self.subplots[label] = DVHSubplot(
						subplot_axes, left=bool(col==0),
						bottom=bool(row==self.rows - 1))

				if not panel in self.__panel_subplots:
					self.__panel_subplots[panel] = self.subplots[label]

		@property
		def upper_right_subplot(self):
			"""
			Return handle to upper-right-most subplot.

			Returns:
				:class:`DVHSubplot`
			"""
			return self.__panel_subplots[self.cols - 1]

		@staticmethod
		def panels_to_cols(n_panels):
			"""
			Convert number of panels to number of subplot columns.

			Used to standardize and balance subplot layout when using
			multiple structures. Prioritizes horizontal expansion over
			vertical expansion up to a maximum of 4 columns.

			Args:
				n_panels (:obj:`int`): number of subplot panels.

			Returns:
				:obj:`int`: number of subplot columns.

			Raises:
				None
			"""
			n_cols = 1
			if n_panels > 1:
				n_cols += 1
			if n_panels > 4:
				n_cols += 1
			if n_panels > 6:
				n_cols += 1
			return n_cols

		@property
		def rows(self):
			""" Number of subplot rows. """
			return self.__rows

		@property
		def cols(self):
			""" Number of subplot columns. """
			return self.__cols

		@property
		def n_panels(self):
			""" Total number of suplots. """
			return self.cols * self.rows

		@property
		def layout(self):
			"""
			Subplot layout: ``'auto'``, ``'vertical'``, or ``'horizontal'``.

			Raises:
				ValueError: If argument to setter is not one of the
					three accepted layout strings.
			"""
			return self.__layout

		@layout.setter
		def layout(self, layout):
			layout = str(layout)
			if layout not in ('auto', 'vertical', 'horizontal'):
				raise ValueError('argument `layout` must be one of:\n'
								 '-"auto"\n-"vertical"\n-"horizontal"')
			if layout != self.__layout:
				self.__layout = layout
				self.clear()
				self.calculate_panels()
				self.build()

		def calculate_panels(self):
			"""
			Calculate number of subplot rows and columns in DVHPlot,
			given the series->panel assignements and layout
			specification.
			"""
			n_panels = max(self.series_panels.values()) + 1
			if self.layout == 'vertical':
				self.__cols = 1
				self.__rows = n_panels
			elif self.layout == 'horizontal':
				self.__cols = n_panels
				self.__rows = 1
			else:  # if self.layout == 'auto':
				self.__cols = self.panels_to_cols(n_panels)
				self.__rows = int(ceil(float(n_panels) / self.__cols))

		@property
		def series_panels(self):
			"""
			Dictionary of series subplot indices keyed by series labels.
			"""
			return self.__panels_by_structure

		@series_panels.setter
		def series_panels(self, panels_by_structure):
			self.__panels_by_structure = {}
			for label in panels_by_structure:
				panel = panels_by_structure[label]
				self.__panels_by_structure[label] = panel

			self.calculate_panels()

		@property
		def series_names(self):
			""" Dictionary of series names keyed by series labels. """
			return self.__names_by_structure

		@series_names.setter
		def series_names(self, names_by_structure):
			self.__names_by_structure = {}
			for label in names_by_structure:
				self.__names_by_structure[label] = names_by_structure[label]

		@property
		def series_colors(self):
			""" Dictionary of series colors keyed by series labels. """
			return self.__colors_by_structure

		@series_colors.setter
		def series_colors(self, colors_by_structure):
			for label in colors_by_structure:
				self.__colors_by_structure[label] = colors_by_structure[label]

		def autoset_series_colors(self, structure_order_dict=None,
								  colormap='viridis'):
			"""
			Set series colors with (possibly default) :class:`LinearSegmentedColormap`.

			Args:
				structure_order_dict (:obj:`dict`, optional): Dictionary
					mapping series (i.e., structure) label keys to int
					values that give the rank-order of the series;
					permuting order allows different colors to be
					assigned to different series.
				colormap (:obj:`str`, optional) Assumed to be valid
					:mod:`matplotlib.pyplot` colormap name.

			Returns:
				None
			"""
			if isinstance(colormap, LinearSegmentedColormap):
				colors = listmap(colormap, linspace(
						0.1, 0.9, self.n_structures))
			else:
				cmap = get_cmap(colormap)
				colors = listmap(cmap, linspace(
						0.9, 0.1, self.n_structures))

			for idx, label in enumerate(self.series_panels.keys()):
				if structure_order_dict is not None:
					self.series_colors[label] = colors[structure_order_dict[label]]
				else:
					self.series_colors[label] = colors[idx]

		@staticmethod
		def get_max_dose(data, suppress_constraints=False):
			"""
			Get maximum dose associated with dataset (DVH curve and dose
			constraints)

			Args:
				data (:obj:`dict`): Dictionary of plotting data
					consistent with output of
					:meth:`~conrad.medicine.Structure.plotting_data`.
				suppress_constraints (:obj:`bool`, optional): If
					``True``, ignore dose constraints when determining
					maximum dose.
			"""
			xmax = 0
			for series in data.values():
				xmax = max(xmax, series['curve']['dose'][-1])
				if not suppress_constraints:
					for constraint in series['constraints']:
						xmax = max(xmax, constraint[1]['dose'][0])
			return xmax

		def entitle_panel(self, panel, title):
			"""
			Apply ``title`` to DVHPlot's subplot number ``panel``.

			Args:
				panel (:obj:`int`): Index of panel to entitle.
				title (:obj:`str`): Title to be applied.

			Returns:
				None
			"""
			self.__panel_subplots[panel].entitle(title)

		def enable_meta_legend(self, series, names, legend_alignment=None,
							   legend_coordinates=None, legend_border=True,
							   legend_shadow=True, legend_box_rounded=False,
							   legend_fontsize=10, **legend_options):
			"""
			Draw figure (not subplot) legend comprising the specified
			series, labeled with the specified names.

			Args:
				series(:obj:`list`): List of :mod:`matplotlib` series
					(i.e., ``artist`` objects) to render in legend.
				names (:obj:`list` of :obj:`str`): Names of series in
					legend.
				legend_alignment (:obj:`str`, optional): Legend location
					relative to legend anchor position. Should conform
					to specification for keyword argument ``loc`` of
					:meth:``matplotlib.figure.Figure.legend``.
				legend_coordinates (optional): Legend anchor position,
					in (x,y)-coordinates, relative to lower left corner
					of figure (upper right corner is ``(1,1)``).
				legend_border (:obj:`bool`, optional): If ``True``, draw
					legend box with border.
				legend_shadow (:obj:`bool`, optional): If ``True``, draw
					legend box with shadow effect.
				legend_box_rounded (:obj:`bool`, optional): If ``True``,
					draw legend box with rounded corners.
				legend_fontsize (:obj:`int` or :obj:`float`, optional):
					Fontsize, in points, to use in legend.
				legend_options: Keyword arguments passed to
					:meth:`~matplotlib.figures.Figure.legend`

			Returns:
				None
			"""
			legend_args = {
				'ncol':1,
				'loc':'upper right',
				'columnspacing':1.0,
				'labelspacing':0.0,
				'handletextpad':0.0,
				'handlelength':2.0,
				'fontsize': legend_fontsize,
				'fancybox': legend_box_rounded,
				'shadow': legend_shadow,
			}
			if legend_alignment is not None:
				legend_args['loc'] = legend_alignment
			if legend_coordinates is not None:
				legend_args['bbox_to_anchor'] = legend_coordinates
			legend = self.figure.legend(series, names, **legend_args)
			if not legend_border:
				frame = legend.get_frame()
				frame.set_edgecolor('1.0')
				frame.set_facecolor('1.0')

		def plot_structure_data(self, label, data, aesthetic=None,
								large_markers=False,
								suppress_constraints=False, suppress_rx=False,
								self_title=False, add_to_legend=True,
								**options):
			"""
			TODO: DESCRIPTION

			Args:
				label: DESCRIPTION
				data: DESCRIPTION
				aethetic (:class:`LineAesthetic`, optional): DESCRIPTION
				large_markers (:obj:`bool`, optional): DESCRIPTION
				suppress_constraints (:obj:`bool`, optional): DESCRIPTION
				suppress_rx (:obj:`bool`, optional): DESCRIPTION
				self_title (:obj:`bool`, optional): DESCRIPTION
				add_to_legend (:obj:`bool`, optional): DESCRIPTION
				**options: Keyword arguments passed to
					:meth:`matplotlib.figure.Figure.plot`.

			Returns:
				None
			"""
			add_to_legend = bool(add_to_legend) and not self_title

			structure_name = data['name']
			series_name = self.series_names[label] if add_to_legend else None
			color = self.series_colors[label]
			subplot = self.subplots[label]


			dvh = subplot.plot_dvh(data['curve'], color, aesthetic=aesthetic,
						  		   series_label=series_name, **options)
			if add_to_legend:
				self.__legend_series.append(dvh)
				self.__legend_names.append(series_name)

			if not suppress_constraints:
				subplot.plot_dose_constraints(data['constraints'], color,
											  large_markers=large_markers)

			if data['rx'] > 0 and not suppress_rx:
				subplot.plot_rx(data['rx'], color)

			if self_title:
				subplot.entitle(structure_name)

		def plot_virtual(self, series_names, series_aesthetics,
						 legend_alignment=None, legend_coordinates=None,
						 **legend_options):
			"""
			Add series to DVH Plot that only appear in legend.

			Enable figure's overall legend (i.e., not a subplot legend).

			Args:
				series_names (): DESCRIPTION
				series_aesthetics (): DESCRIPTION
				legend_alignment (optional): Legend location relative to
					legend anchor position.
				legend_coordinates (optional): Legend anchor position,
					in (x,y)-coordinates, relative to lower left corner
					of figure (upper right corner is ``(1,1)``).
				legend_options: Keyword arguments passed to
					:meth:`~matplotlib.figures.Figure.legend`

			Returns:
				None
			"""
			#subplot or upper right panel
			upper_right = self.upper_right_subplot
			series = []

			for name, aesthetic in zip(series_names, series_aesthetics):
				virtual_line = mpl.lines.Line2D(
						[], [], label=name, **aesthetic.plot_args('#222222'))
				series.append(virtual_line)

			self.enable_meta_legend(series, series_names,
									legend_alignment=legend_alignment,
									legend_coordinates=legend_coordinates,
									**legend_options)

		def plot(self, plot_data, show=False, clear=True, xmax=None,
				 legend=True, title=None, self_title_subplots=False,
				 large_markers=False, suppress_constraints=False,
				 x_label='Dose (Gy)', y_label='Percentile',
				 legend_coordinates=None, legend_alignment=None,
				 aesthetic=None, minimal_axes=True, **options):
			"""
			Plot ``plot_data`` to the object's :class:`matplotlib.Figure`.

			The input ``plot_data`` should a :obj:`dict` with the
			following scheme::

				{
					series_label_1: {
						curve: {
							dose: numpy.ndarray, # (x data)
							percentile: numpy.ndarray # (y data)
						},
						constraints:[
							{
								dose: [float, float], #(value, value +/- slack)
							  	percentile: [float, float],
							  	symbol: char #(i.e., '<' or '>')
							 }, ..
						]
					},
					..
				}

			Args:
				plot_data (:obj:`dict`) Collection of DVH curves, keyed
					by structure/series label, with format specified
					above.
				show (:obj:`bool`, optional): Show
					:class:`matplotlib.Figure` canvas after
					``plot_data`` elements are drawn.
				clear (:obj:`bool`, optional): Clear
					:class:`matplotlib.Figure` before ``plot_data``
					elements are drawn.
				xmax (:obj:`float`, optional): Upper limit for x-axis
					set to this value if provided. Otherwise, upper
					limit set to 110% of largest dose encountered in
					``plot_data``.
				legend (optional): Enable legend in
					:class:`matplotlib.Figure`. Set overall legend if
					value is ``True``, set legend per subplot if value
					is ``'each'``, set legend in upper-right-most
					subplot if value is ``'upper_right'``.
				title (:obj:`str`, optional): Contents drawn as title of
					:class:`matplotlib.Figure`.
				large_markers (:obj:`bool`, optional): Draw dose volume
					constraints with larger size markers.
				suppress_constraints (:obj:`bool`, optional): Suppress
					rendering of dose volume constraints.
				x_label (:obj:`str`, optional): x-axis label.
				y_label (:obj:`str`, optional): y-axis label.
				legend_coordinates (:obj:`list`, optional): Position, as
				 	(x,y)-coordinates, of legend anchor relative to
				 	figure; passed as kewyword argument ``bbox_to_anchor``
				 	in  :meth:`matplotlib.Figure.legend`.
				legend_alignment (:obj:`str`, optional): String defining
					alignment of legend relative to anchor, passed as
					keyword argument ``loc`` in
					:meth:`matplotlib.Figure.legend`.
				**options: Arbitrary keyword arguments, passed to
					:meth:`matplotlib.Figure.plot`.

			Returns:
				None
			"""
			if clear:
				self.clear()

			# get figure, subplot axes,
			if self.figure is None:
				self.build()

			# get x-axis limits
			max_dose = self.get_max_dose(
					plot_data, suppress_constraints=suppress_constraints)
			xlim_upper = xmax if xmax is not None else 1.1 * max_dose

			# plot title
			if title is not None:
				self.figure.suptitle(title)

			# format subplots:
			counter = 0
			for subplot in self.subplots.values():
				counter += 1
				subplot.format(xlim_upper, x_label, y_label,
							   minimal_axes=minimal_axes)

			self.figure.subplots_adjust(left=0.09, bottom=0.1, right=0.99,
										top=0.99, wspace=0.1, hspace=0.15)

			# plot data
			for label, data in plot_data.items():
				self.plot_structure_data(
						label, data, aesthetic=aesthetic,
						large_markers=large_markers, add_to_legend=legend,
						suppress_constraints=suppress_constraints,
						self_title=self_title_subplots, **options)


			# draw legends, per subplot or overall
			for subplot in self.subplots.values():
				subplot_legend = legend == 'each'
				subplot_legend |= bool(legend == 'upper_right' and
									   subplot == self.upper_right_subplot)

				if subplot_legend:
					subplot.enable_legend()

			if bool(isinstance(legend, bool) and legend and
					len(self.__legend_series) > 0):
				self.enable_meta_legend(
						self.__legend_series, self.__legend_names,
						legend_alignment=legend_alignment,
						legend_coordinates=legend_coordinates, **options)

			if show:
				self.show()

		def show(self):
			"""
			If matplotlib is in communication with a display, render
			plot onscreen. "
			"""
			SHOW()

		def save(self, filepath, overwrite=True, verbose=False):
			"""
			Save the object's current plot to ``filepath``.

			Args:
				filepath (:obj:`str`): Specify path to save plot.
				overwrite (bool):, Allow overwrite of file at
					``filepath``if ``True``.
				verbose (:obj:`bool`): Print confirmation of save if
					``True``.

			Returns:
				None

			Raises:
				ValueError: If ``filepath`` does not exist *or* is an
					existing file and flag ``overwrite`` is ``False``.
				RuntimeError: If save fails for any other reason.
			"""
			filepath = path.abspath(filepath)
			directory = path.dirname(filepath)
			if not path.isdir(path.dirname(filepath)):
				raise ValueError(
						'argument "filepath" specified with invalid'
						'directory')
			elif not overwrite and path.exists(filepath):
				raise ValueError(
						'argument "filepath" specifies an existing file'
						'and argument "overwrite" is set to False')
			else:
				try:
					if verbose:
						print("SAVING TO ", filepath)
					self.figure.savefig(filepath, bbox_inches='tight')
				except:
					raise RuntimeError(
							'could not save plot to file: {}'.format(filepath))

		def __del__(self):
			"""
			Close object's :class:`matplotlib.Figure` when out of scope.
			"""
			self.clear()

	class CasePlotter(object):
		"""
		Wrap :class:`DVHPlot` for visualizing treatment plan data.

		Attributes:
			dvh_plot (:class:`DVHPlot`): Dose volume histogram plot.

		Examples:
			>>> # intialize based on an existing :class:`Case` object "case"
			>>> plotter = CasePlotter(case)

			>>> # form treatment plan with case
			>>> _, run = case.plan(**args)

			>>> # plot the output emitted by the case.plan() call
			>>> plotter.plot(run, **options)
		"""

		def __init__(self, case, subset=None):
			"""
			Initialize :class:`CasePlotter`.

			Use structure information from ``case`` to initialize a
			:class:`DVHPlot` object with the names and labels of each
			structure associated with the case.

			Args:
				case (:class:`Case`): Treatment planning case to use as
					basis for configuring object's :class:`DVHPlot`
				subset (:obj:`list`, optional): List of labels of
					structures to use in a restricted plotting context.

			Raises:
				TypeError: If argument is not of type :class:`Case`
			"""
			if not isinstance(case, Case):
				TypeError('argument "case" must be of type conrad.Case')

			if subset is None:
				subset = case.anatomy.label_order

			# plot setup
			panels_by_structure = {label: 1 for label in subset}
			names_by_structure = {
					label: case.anatomy[label].name for label in subset}
			self.dvh_plot = DVHPlot(panels_by_structure, names_by_structure)
			self.__labels = {}
			self.__grouping = 'together'
			for s in case.anatomy:
				if s.label in subset:
					self.__labels[s.label] = s.label
					self.__labels[s.name] = s.label

		def label_is_valid(self, label):
			"""
			``True`` if ``label`` is a structure name or label
			associated with the case (or subset thereof) associated with
			this :class:`CasePlotter`.
			"""
			return label in self.__labels

		def set_display_groups(self, grouping='together', group_list=None):
			"""
			Specify structure-to-panel assignments for display.

			Args:
				grouping (:obj:`str`, optional): Should be one of
					'together', 'separate', or 'list'. If 'together',
					all curves plotted on single panel. If 'separate',
					each curve plotton on its own panel. If 'list',
					curves grouped according to ``group_list``.
				group_list (:obj:`list` of :obj:`tuple`, optional): If
						provided, each element of the i-th :obj:`tuple`
						is assumed to be a valid structure label, and
						the DVH curve for the corresponding structure is
						assigned to panel i.

			Returns:
				None

			Raises:
				TypeError: If ``grouping`` is not a :obj:`str` or
					members of ``group_list`` are not each a
					:obj:`tuple`.
				ValueError: If ``grouping`` is not one of ('together',
					separate', 'list'); *or* if each label in each tuple
					in ``group_list`` does not correspond to a structure
					label in the case used to initialize this
					:class:`CasePlotter`.
			"""

			if not isinstance(grouping, str):
				raise TypeError('argument "grouping" must be of type {}'
								''.format(str))
			if grouping not in ('together', 'separate', 'list'):
				raise ValueError('argument "grouping" must be one of '
								 'the following: ("together", '
								 '"separate", or "list")')

			if grouping == 'together':
				for key in self.dvh_plot.series_panels:
					self.dvh_plot.series_panels[key] = 0
			elif grouping == 'separate':
				for i, key in enumerate(self.dvh_plot.series_panels):
					self.dvh_plot.series_panels[key] = i
			elif grouping == 'list':
				valid = isinstance(group_list, list)
				valid &= all(map(lambda x: isinstance(x, tuple), group_list))
				if valid:
					for i, group in enumerate(group_list):
						for label in group:
							if self.label_is_valid(label):
								self.dvh_plot.series_panels[
										self.__labels[label]] = i
							else:
								raise ValueError(
										'specified label {} in tuple {} '
										'does not correspond to any '
										'known structure labels in the '
										'current case'
										''.format(label, group))
				else:
					raise TypeError('argument "group_list" must be a {} '
									'of {}s'.format(list, tuple))

			self.dvh_plot.clear()
			self.__grouping = grouping
			self.dvh_plot.calculate_panels()
			self.dvh_plot.build()

		def plot(self, data, second_pass=False, show=False, clear=True,
				 subset=None, plotfile=None, aesthetic=None, **options):
			"""
			Plot dose volume histograms from argument `data`.

			Args:
				data (:obj:`dict`, or :class:`RunRecord`): Used to build
					the DVH curves. Assumed to be compatible with the
					`Case` used to initialize this object.
				second_pass (:obj:`bool`, optional): Plot data from
					second planning pass when ``True`` and ``data`` is a
					:class:`RunRecord`.
				show (:obj:`bool`, optional): Show figure after drawing.
				clear (:obj:`bool`, optional): Clear figure before
					rendering data in ``data``.
				subset (:obj:`list` or :obj:`tuple`, optional): Specify
					labels of DVH curves to be plotted; others are
					suppressed. All structures' DVH curves are plotted
					by default.
				plotfile (:obj:`str`, optional): Passed to to the
					:class:`DVHPlot` as a target filepath to save the
					drawn plot.
				aesthetic (:class:`LineAesthetic`, optional): Passed to
					:meth:`~DVHPlot.plot` to apply to the DVH curves.
				**options: Arbitrary keyword arguments passed through to
					:meth:`~DVHPlot.plot`.

			Returns:
				None

			Raises:
				TypeError: If ``subset`` is specified but not a
					:obj:`list` or :obj:`tuple`.
				KeyError: If ``subset`` is specified but contains items
					that are not recognized as valid structure labels.
			"""
			if plotfile is None:
				plotfile = options.pop('file', None)
			if isinstance(data, RunRecord):
				if second_pass and data.plotting_data['exact'] is not None:
					data = data.plotting_data['exact']
				else:
					data = data.plotting_data[0]
			data_ = data

			# filter data to only plot DVH for structures with requested labels
			if subset is None:
				data = {}

				for label in data_:
					if label in self.__labels:
						data[label] = data_[label]
			else:
				if not isinstance(subset, (list, tuple)):
					raise TypeError('argument "subset" must be of type {} or '
									'{}'.format(list, tuple))
				if not all([label in data_.keys() for label in subset]):
					raise KeyError('argument "subset" specifies an invalid '
								   'structure label')
				data = {}
				for label in subset:
					data[label] = data_[label]


			if 'self_title_subplots' in options:
				options['self_title_subplots'] &= self.__grouping == 'separate'

			self.dvh_plot.plot(data, clear=clear, aesthetic=aesthetic,
							   **options)
			if show:
				self.dvh_plot.show()
			if plotfile is not None:
				self.dvh_plot.save(plotfile)

		def plot_multi(self, run_data, run_names, reference_data=None,
					   reference_name='reference', show=False, clear=True,
				 	   subset=None, plotfile=None, layout='auto',
				 	   vary_markers=True, vary_marker_sizes=False,
				 	   marker_size_increasing=True,
				 	   universal_marker=None, vary_line_weights=False,
				 	   vary_line_colors=False, vary_line_styles=False,
				 	   darken_reference=True, **options):
			"""
			Plot data from multiple runs.

			Args:
				run_data (:obj:`list` of :class:`RunRecord` or :obj:`dict`):
					List of plans to be plotted.
				run_names (:obj:`list` of :obj:`str`):
					List of names to associate with each compared plan.
				reference_data (:class:`RunRecord` or :obj:`dict`, optional):
					Reference plan.
				reference_name (:obj:`str`, optional): Name of reference
					plan.
				show (:obj:`bool`, optional): If ``True``, display
					resulting plot in GUI.
				clear (:obj:`bool`, optional): If ``True``, clear canvas
					before drawing DVH curves for specified plans.
				subset (:obj:`list`, optional): If provided, should be a
					list of labels/names of structures in the case; DVH
					curves will be plotted for only the requested subset.
				plotfile (:obj:`str`, optional): If provided, result
					will be saved to the specified path.
				layout (:obj:`str`, optional): Set layout of DVH plot to
					be one of ``'auto'``, ``'horizontal'``, or
					``'vertical'`` to arrange subplots.
				vary_markers (:obj:`bool`, optional): If ``True``,
					marker styles for DVH curves of each non-reference
					plan will be cycled among 6 styles.
				vary_marker_sizes (:obj:`bool`, optional): If ``True``,
					plot DVH curves with different marker sizes for each
					non-reference plan.
				marker_size_increasing (:obj:`bool`, optional): If
					``True``, the DVH curves for non-reference plans
					will be drawn with markers of increasing size. If
					``False``, this is reversed. Increasing/decreasing
					size is applied according to the plans' list order
					in ``run_data``.
				universal_marker (:obj:`str`, optional): If set to a
					valid :mod:`matplotlib` marker string, each
					non-reference plan will be plotted with that marker
					(increasing marker size will be enabled to
					differentiate plans).
				vary_line_weights (:obj:`bool`, optional): If ``True``,
					the DVH curves for non-reference plans will be drawn
					with lines of increasing weight. Increasing weight
					is applied according to the plans' list order in
					``run_data``.
				vary_line_colors (:obj:`bool`, optional): If ``True``,
					attenuate color assigned to each structure's DVH
					curve (use weighted average of specified color and
					black) when plotting each non-reference data series.
				vary_line_styles (:obj:`bool`, optional): If ``True``,
					line styles for DVH curves of each non-reference
					plan will be cycled among 4 styles.
				darken_reference (:obj:`bool`, optional): If ``True``,
					attenuate color assigned to each structure's DVH
					curve (use weighted average of specified color and
					black) when plotting reference series.
				**options: Keyword arguments passed to
					:meth:`CasePlotter.plot`
			"""
			n_compared = len(run_data) + int(reference_data is not None)
			run_aesthetics = [LineAesthetic() for i in xrange(n_compared)]

			line_styles = ['-', '-.', '--', ':']
			if len(run_data) > 4 and vary_line_styles:
				vary_markers = True

			vary_markers &= universal_marker is None
			vary_marker_sizes |= universal_marker is not None
			marker_styles = ['o', 's', '^']
			fill_styles = ['none', 'full']
			if len(run_data) > 6 and vary_markers:
				vary_line_styles = True

			weight_step = 0.5
			min_weight = 0.5
			max_weight = 2.0
			if vary_line_weights:
				max_weight = max(
						max_weight, min_weight + weight_step * n_compared)

			max_attenuation = 0.7
			min_attentuation = 1.0
			attenuation_step = -0.5 / n_compared

			# set layout
			self.dvh_plot.layout = layout

			# set aesthetics for each data series
			for i, run in enumerate(run_data):
				if vary_line_styles:
					run_aesthetics[i].style = line_styles[i % 4]
				if universal_marker is not None:
					run_aesthetics[i].marker = universal_marker
				if vary_markers:
					run_aesthetics[i].marker = marker_styles[i % 3]
					run_aesthetics[i].fill = fill_styles[i % 2]
				if vary_marker_sizes:
					if marker_size_increasing:
						run_aesthetics[i].markersize = 4 + 2 * i
					else:
						run_aesthetics[i].markersize = 4 + 2 * (n_compared - 1 - i)
				if vary_line_weights:
					run_aesthetics[i].weight = min_weight + i * weight_step
				if vary_line_colors:
					run_aesthetics[i].color_attenuation = 1.0 - i * attenuation_step

			# set reference aesthetics
			if reference_data is not None:
				run_data.append(reference_data)
				run_names.append(str(reference_name))

				run_aesthetics[-1].weight = max_weight
				if darken_reference:
					run_aesthetics[-1].color_attenuation = max_attenuation

			# get single x-window appropriate across all compared series
			options['xmax'] = options.pop(
					'xmax', max([self.dvh_plot.get_max_dose(d) for d in run_data]))

			if clear:
				self.dvh_plot.clear()

			# plot each data series
			for i in xrange(n_compared):
				if i == 0:
					options['self_title_subplots'] = True

				self.plot(run_data[i], clear=False, subset=subset, legend=False,
						  aesthetic=run_aesthetics[i], **options)

			# plot legend
			self.dvh_plot.plot_virtual(run_names, run_aesthetics)

			if show:
				self.dvh_plot.show()
			if plotfile is not None:
				self.dvh_plot.save(plotfile)
